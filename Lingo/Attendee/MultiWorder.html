<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class Lingo::Attendee::MultiWorder - lingo Application documentation (v1.8.4)</title>

<link href="../../fonts.css" rel="stylesheet">
<link href="../../rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "../../";
</script>

<script src="../../js/jquery.js"></script>
<script src="../../js/navigation.js"></script>
<script src="../../js/search_index.js"></script>
<script src="../../js/search.js"></script>
<script src="../../js/searcher.js"></script>
<script src="../../js/darkfish.js"></script>


<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../table_of_contents.html#pages">Pages</a>
    <a href="../../table_of_contents.html#classes">Classes</a>
    <a href="../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
<div class="nav-section">
  <h3>Table of Contents</h3>

  <ul class="link-list" role="directory">
    <li><a href="#class-Lingo::Attendee::MultiWorder-label-M%C3%B6gliche+Verlinkung">Mögliche Verlinkung</a>
    <li><a href="#class-Lingo::Attendee::MultiWorder-label-Parameter">Parameter</a>
    <li><a href="#class-Lingo::Attendee::MultiWorder-label-Beispiele">Beispiele</a>
  </ul>
</div>


  <div id="class-metadata">
    
    <div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  
  <p class="link">BufferedAttendee
  
</div>

    
    
    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li ><a href="#method-i-check_multiword_key">#check_multiword_key</a>
    
    <li ><a href="#method-i-control">#control</a>
    
    <li ><a href="#method-i-create_and_forward_multiword">#create_and_forward_multiword</a>
    
    <li ><a href="#method-i-init">#init</a>
    
    <li ><a href="#method-i-process_buffer">#process_buffer</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-Lingo::Attendee::MultiWorder">
  <h1 id="class-Lingo::Attendee::MultiWorder" class="class">
    class Lingo::Attendee::MultiWorder
  </h1>

  <section class="description">
    
<p>Mit der bisher beschriebenen Vorgehensweise werden die durch den <a
href="Tokenizer.html">Tokenizer</a> erkannten Token aufgelöst und in Words
verwandelt und über den <a href="Abbreviator.html">Abbreviator</a> und <a
href="Decomposer.html">Decomposer</a> auch Spezialfälle behandelt, die
einzelne Wörter betreffen. Um jedoch auch Namen wie z.B. John F. Kennedy
als Sinneinheit erkennen zu können, muss eine Analyse über mehrere Objekte
erfolgen. Dies ist die Hauptaufgabe des MultiWorders. Der <a
href="MultiWorder.html">MultiWorder</a> analysiert die Teile des
Datenstroms, die z.B. durch Satzzeichen oder weiteren Einzelzeichen (z.B.
&#39;(&#39;) begrenzt sind. Erkannte Mehrwortgruppen werden als
zusätzliches Objekt in den Datenstrom mit eingefügt.</p>

<h3 id="class-Lingo::Attendee::MultiWorder-label-M%C3%B6gliche+Verlinkung">Mögliche Verlinkung<span><a href="#class-Lingo::Attendee::MultiWorder-label-M%C3%B6gliche+Verlinkung">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<dl class="rdoc-list note-list"><dt>Erwartet
<dd>
<p>Daten vom Typ <strong>Word</strong> z.B. von Wordsearcher, <a
href="Decomposer.html">Decomposer</a>, Ocr_variator, <a
href="MultiWorder.html">MultiWorder</a></p>
</dd><dt>Erzeugt
<dd>
<p>Daten vom Typ <strong>Word</strong> (mit Attribut WA_MULTIWORD). Je
erkannter Mehrwortgruppe wird ein zusätzliches Word-Objekt in den
Datenstrom eingefügt. Z.B. für Ocr_variator, <a
href="Sequencer.html">Sequencer</a>, Noneword_filter, Vector_filter</p>
</dd></dl>

<h3 id="class-Lingo::Attendee::MultiWorder-label-Parameter">Parameter<span><a href="#class-Lingo::Attendee::MultiWorder-label-Parameter">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p>Kursiv dargestellte Parameter sind optional (ggf. mit Angabe der
Voreinstellung). Alle anderen Parameter müssen zwingend angegeben werden.</p>
<dl class="rdoc-list note-list"><dt><strong>in</strong>
<dd>
<p>siehe allgemeine Beschreibung des <a href="../Attendee.html">Attendee</a></p>
</dd><dt><strong>out</strong>
<dd>
<p>siehe allgemeine Beschreibung des <a href="../Attendee.html">Attendee</a></p>
</dd><dt><strong>source</strong>
<dd>
<p>siehe allgemeine Beschreibung des Dictionary</p>
</dd><dt><strong><em>mode</em></strong>
<dd>
<p>(Standard: all) siehe allgemeine Beschreibung des Dictionary</p>
</dd></dl>

<h3 id="class-Lingo::Attendee::MultiWorder-label-Beispiele">Beispiele<span><a href="#class-Lingo::Attendee::MultiWorder-label-Beispiele">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p>Bei der Verarbeitung einer normalen Textdatei mit der Ablaufkonfiguration
<code>t1.cfg</code></p>

<pre>meeting:
  attendees:
    - text_reader:   { out: lines, files: &#39;$(files)&#39; }
    - tokenizer:     { in: lines, out: token }
    - abbreviator:   { in: token, out: abbrev, source: &#39;sys-abk&#39; }
    - word_searcher: { in: abbrev, out: words, source: &#39;sys-dic&#39; }
    - decomposer:    { in: words, out: comps, source: &#39;sys-dic&#39; }
    - multi_worder:  { in: comps, out: multi, source: &#39;sys-mul&#39; }
    - debugger:      { in: multi, prompt: &#39;out&gt;&#39; }</pre>

<p>ergibt die Ausgabe über den Debugger: <code>lingo -c t1 test.txt</code></p>

<pre>out&gt; *FILE(&#39;test.txt&#39;)
out&gt; &lt;Sein = [(sein/s), (sein/v)]&gt;
out&gt; &lt;Name = [(name/s)]&gt;
out&gt; &lt;ist = [(sein/v)]&gt;
out&gt; &lt;johann van siegen|MUL = [(johann van siegen/m)]&gt;
out&gt; &lt;Johann = [(johann/e)]&gt;
out&gt; &lt;van = [(van/w)]&gt;
out&gt; &lt;Siegen = [(sieg/s), (siegen/v), (siegen/e)]&gt;
out&gt; :./PUNC:
out&gt; *EOL(&#39;test.txt&#39;)
out&gt; *EOF(&#39;test.txt&#39;)</pre>

  </section>

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    

    

    
     <section id="protected-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Protected Instance Methods</h3>
       </header>

    
      <div id="method-i-control" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">control</span><span
            class="method-args">(cmd, param)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="control-source">
            <pre><span class="ruby-comment"># File lib/lingo/attendee/multi_worder.rb, line 114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">control</span>(<span class="ruby-identifier">cmd</span>, <span class="ruby-identifier">param</span>)
  <span class="ruby-identifier">control_multi</span>(<span class="ruby-identifier">cmd</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-init" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">init</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="init-source">
            <pre><span class="ruby-comment"># File lib/lingo/attendee/multi_worder.rb, line 79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">init</span>
  <span class="ruby-comment"># combine lexical variants?</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># false = old behaviour</span>
  <span class="ruby-comment"># true  = first match</span>
  <span class="ruby-comment"># &#39;all&#39; = all matches</span>
  <span class="ruby-ivar">@combine</span> = <span class="ruby-identifier">get_key</span>(<span class="ruby-string">&#39;combine&#39;</span>, <span class="ruby-keyword">false</span>)
  <span class="ruby-ivar">@all</span>     = <span class="ruby-ivar">@combine</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">String</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-ivar">@combine</span>.<span class="ruby-identifier">downcase</span> <span class="ruby-operator">==</span> <span class="ruby-string">&#39;all&#39;</span>

  <span class="ruby-identifier">lex_src</span>, <span class="ruby-identifier">lex_mod</span>, <span class="ruby-identifier">d</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">lingo</span>.<span class="ruby-identifier">dictionary_config</span>[<span class="ruby-string">&#39;databases&#39;</span>]

  (<span class="ruby-identifier">mul_src</span> = <span class="ruby-identifier">get_array</span>(<span class="ruby-string">&#39;source&#39;</span>)).<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">src</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">s</span>, <span class="ruby-identifier">m</span> = <span class="ruby-identifier">d</span>[<span class="ruby-identifier">src</span>].<span class="ruby-identifier">values_at</span>(<span class="ruby-string">&#39;use-lex&#39;</span>, <span class="ruby-string">&#39;lex-mode&#39;</span>)

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">lex_src</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">lex_src</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">s</span>
      <span class="ruby-identifier">lex_src</span>, <span class="ruby-identifier">lex_mod</span> = <span class="ruby-identifier">s</span>, <span class="ruby-identifier">m</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">warn</span> <span class="ruby-node">&quot;#{self.class}: Dictionaries don&#39;t match: #{mul_src.join(&#39;,&#39;)}&quot;</span>
    <span class="ruby-keyword">end</span>
  }

  <span class="ruby-identifier">lex_src</span> = <span class="ruby-identifier">lex_src</span>.<span class="ruby-identifier">split</span>(<span class="ruby-constant">SEP_RE</span>)
  <span class="ruby-identifier">lex_mod</span> = <span class="ruby-identifier">get_key</span>(<span class="ruby-string">&#39;lex-mode&#39;</span>, <span class="ruby-identifier">lex_mod</span> <span class="ruby-operator">||</span> <span class="ruby-string">&#39;first&#39;</span>)

  <span class="ruby-ivar">@mul_dic</span> = <span class="ruby-identifier">dictionary</span>(<span class="ruby-identifier">mul_src</span>, <span class="ruby-identifier">get_key</span>(<span class="ruby-string">&#39;mode&#39;</span>, <span class="ruby-string">&#39;all&#39;</span>))
  <span class="ruby-ivar">@lex_dic</span> = <span class="ruby-identifier">dictionary</span>(<span class="ruby-identifier">lex_src</span>, <span class="ruby-identifier">lex_mod</span>)
  <span class="ruby-ivar">@lex_gra</span> = <span class="ruby-identifier">grammar</span>(<span class="ruby-identifier">lex_src</span>, <span class="ruby-identifier">lex_mod</span>)

  <span class="ruby-ivar">@syn_dic</span> = <span class="ruby-keyword">if</span> <span class="ruby-ivar">@combine</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">has_key?</span>(<span class="ruby-string">&#39;use-syn&#39;</span>)
    <span class="ruby-identifier">dictionary</span>(<span class="ruby-identifier">get_array</span>(<span class="ruby-string">&#39;use-syn&#39;</span>), <span class="ruby-identifier">get_key</span>(<span class="ruby-string">&#39;syn-mode&#39;</span>, <span class="ruby-string">&#39;all&#39;</span>))
  <span class="ruby-keyword">end</span>

  <span class="ruby-ivar">@expected_tokens_in_buffer</span>, <span class="ruby-ivar">@eof_handling</span> = <span class="ruby-value">3</span>, <span class="ruby-keyword">false</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-process_buffer" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">process_buffer</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="process_buffer-source">
            <pre><span class="ruby-comment"># File lib/lingo/attendee/multi_worder.rb, line 118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">process_buffer</span>
  <span class="ruby-keyword">unless</span> <span class="ruby-identifier">form_at</span>(<span class="ruby-value">0</span>) <span class="ruby-operator">==</span> <span class="ruby-constant">CHAR_PUNCT</span>
    <span class="ruby-keyword">unless</span> (<span class="ruby-identifier">res</span> = <span class="ruby-identifier">check_multiword_key</span>(<span class="ruby-value">3</span>)).<span class="ruby-identifier">empty?</span>
      <span class="ruby-identifier">len</span> = <span class="ruby-identifier">res</span>.<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Lexical</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">form</span>.<span class="ruby-identifier">count</span>(<span class="ruby-string">&#39; &#39;</span>) <span class="ruby-operator">+</span> <span class="ruby-value">1</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">r</span> }
      <span class="ruby-identifier">len</span>.<span class="ruby-identifier">sort!</span>.<span class="ruby-identifier">reverse!</span>

      <span class="ruby-keyword">unless</span> (<span class="ruby-identifier">max</span> = <span class="ruby-identifier">len</span>.<span class="ruby-identifier">first</span>) <span class="ruby-operator">&gt;</span> <span class="ruby-value">3</span>
        <span class="ruby-identifier">create_and_forward_multiword</span>(<span class="ruby-value">3</span>, <span class="ruby-identifier">res</span>)
        <span class="ruby-identifier">forward_number_of_token</span>(<span class="ruby-value">3</span>)
      <span class="ruby-keyword">else</span>
        <span class="ruby-keyword">unless</span> <span class="ruby-ivar">@eof_handling</span> <span class="ruby-operator">||</span> <span class="ruby-ivar">@buffer</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-identifier">max</span>
          <span class="ruby-ivar">@expected_tokens_in_buffer</span> = <span class="ruby-identifier">max</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">forward_number_of_token</span>(<span class="ruby-identifier">len</span>.<span class="ruby-identifier">find</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">l</span><span class="ruby-operator">|</span>
            <span class="ruby-identifier">r</span> = <span class="ruby-identifier">check_multiword_key</span>(<span class="ruby-identifier">l</span>)
            <span class="ruby-identifier">create_and_forward_multiword</span>(<span class="ruby-identifier">l</span>, <span class="ruby-identifier">r</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">empty?</span>
          } <span class="ruby-operator">||</span> <span class="ruby-value">1</span>)

          <span class="ruby-ivar">@expected_tokens_in_buffer</span> = <span class="ruby-value">3</span>
          <span class="ruby-identifier">process_buffer</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">process_buffer?</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>

      <span class="ruby-keyword">return</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">unless</span> (<span class="ruby-identifier">res</span> = <span class="ruby-identifier">check_multiword_key</span>(<span class="ruby-value">2</span>)).<span class="ruby-identifier">empty?</span>
      <span class="ruby-identifier">create_and_forward_multiword</span>(<span class="ruby-value">2</span>, <span class="ruby-identifier">res</span>)
      <span class="ruby-identifier">forward_number_of_token</span>(<span class="ruby-value">1</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">forward_number_of_token</span>(<span class="ruby-value">1</span>, <span class="ruby-keyword">false</span>)
  <span class="ruby-ivar">@expected_tokens_in_buffer</span> = <span class="ruby-value">3</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
     <section id="private-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Private Instance Methods</h3>
       </header>

    
      <div id="method-i-check_multiword_key" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">check_multiword_key</span><span
            class="method-args">(len)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Prüft einen definiert langen Schlüssel ab Position 0 im Buffer</p>
          
          

          
          <div class="method-source-code" id="check_multiword_key-source">
            <pre><span class="ruby-comment"># File lib/lingo/attendee/multi_worder.rb, line 175</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">check_multiword_key</span>(<span class="ruby-identifier">len</span>)
  <span class="ruby-keyword">return</span> [] <span class="ruby-keyword">if</span> <span class="ruby-identifier">valid_tokens_in_buffer</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len</span>

  <span class="ruby-identifier">seq</span> = []

  <span class="ruby-ivar">@buffer</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">obj</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">next</span> <span class="ruby-identifier">seq</span> <span class="ruby-operator">&lt;&lt;</span> [<span class="ruby-identifier">obj</span>] <span class="ruby-keyword">unless</span> <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">WordForm</span>)
    <span class="ruby-keyword">next</span> <span class="ruby-keyword">if</span> (<span class="ruby-identifier">form</span> = <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">form</span>) <span class="ruby-operator">==</span> <span class="ruby-constant">CHAR_PUNCT</span>

    <span class="ruby-identifier">w</span> = <span class="ruby-identifier">find_word</span>(<span class="ruby-identifier">form</span>, <span class="ruby-ivar">@lex_dic</span>, <span class="ruby-ivar">@lex_gra</span>)
    <span class="ruby-identifier">l</span> = <span class="ruby-identifier">w</span>.<span class="ruby-identifier">lexicals</span>

    <span class="ruby-identifier">i</span> = <span class="ruby-identifier">w</span>.<span class="ruby-identifier">attr</span> <span class="ruby-operator">==</span> <span class="ruby-constant">WA_COMPOUND</span> <span class="ruby-operator">?</span> [<span class="ruby-identifier">l</span>.<span class="ruby-identifier">first</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">l</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">?</span> [<span class="ruby-identifier">w</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">l</span>.<span class="ruby-identifier">dup</span>

    <span class="ruby-ivar">@syn_dic</span>.<span class="ruby-identifier">find_synonyms</span>(<span class="ruby-identifier">w</span>, <span class="ruby-identifier">i</span>) <span class="ruby-keyword">if</span> <span class="ruby-ivar">@syn_dic</span>
    <span class="ruby-identifier">i</span>.<span class="ruby-identifier">map!</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">j</span><span class="ruby-operator">|</span> <span class="ruby-constant">Unicode</span>.<span class="ruby-identifier">downcase</span>(<span class="ruby-identifier">j</span>.<span class="ruby-identifier">form</span>) }.<span class="ruby-identifier">uniq!</span>

    <span class="ruby-identifier">seq</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">i</span>

    <span class="ruby-keyword">break</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">seq</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len</span>
  }

  <span class="ruby-keyword">if</span> <span class="ruby-ivar">@combine</span>
    <span class="ruby-identifier">mul</span> = []

    <span class="ruby-identifier">seq</span>.<span class="ruby-identifier">shift</span>.<span class="ruby-identifier">product</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">seq</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span><span class="ruby-operator">|</span>
      <span class="ruby-ivar">@mul_dic</span>.<span class="ruby-identifier">select</span>(<span class="ruby-identifier">key</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&#39; &#39;</span>), <span class="ruby-identifier">mul</span>)
      <span class="ruby-keyword">break</span> <span class="ruby-keyword">unless</span> <span class="ruby-ivar">@all</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">mul</span>.<span class="ruby-identifier">empty?</span>
    } <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">mul</span>.<span class="ruby-identifier">uniq!</span>

    <span class="ruby-identifier">mul</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-ivar">@mul_dic</span>.<span class="ruby-identifier">select</span>(<span class="ruby-identifier">seq</span>.<span class="ruby-identifier">map!</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span>,<span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> }.<span class="ruby-identifier">join</span>(<span class="ruby-string">&#39; &#39;</span>))
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-create_and_forward_multiword" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">create_and_forward_multiword</span><span
            class="method-args">(len, lex)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="create_and_forward_multiword-source">
            <pre><span class="ruby-comment"># File lib/lingo/attendee/multi_worder.rb, line 156</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">create_and_forward_multiword</span>(<span class="ruby-identifier">len</span>, <span class="ruby-identifier">lex</span>)
  <span class="ruby-identifier">pos</span>, <span class="ruby-identifier">parts</span> = <span class="ruby-value">0</span>, []

  <span class="ruby-keyword">begin</span>
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">form</span> = <span class="ruby-identifier">form_at</span>(<span class="ruby-identifier">pos</span>)) <span class="ruby-operator">==</span> <span class="ruby-constant">CHAR_PUNCT</span>
      <span class="ruby-ivar">@buffer</span>.<span class="ruby-identifier">delete_at</span>(<span class="ruby-identifier">pos</span>)
      <span class="ruby-identifier">parts</span>[<span class="ruby-value">-1</span>] <span class="ruby-operator">+=</span> <span class="ruby-constant">CHAR_PUNCT</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-ivar">@buffer</span>[<span class="ruby-identifier">pos</span>].<span class="ruby-identifier">attr</span> = <span class="ruby-constant">WA_UNKMULPART</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@buffer</span>[<span class="ruby-identifier">pos</span>].<span class="ruby-identifier">unknown?</span>
      <span class="ruby-identifier">parts</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">form</span>
      <span class="ruby-identifier">pos</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span> <span class="ruby-keyword">while</span> <span class="ruby-identifier">pos</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len</span>

  <span class="ruby-identifier">forward</span>(<span class="ruby-constant">Word</span>.<span class="ruby-identifier">new_lexicals</span>(<span class="ruby-identifier">parts</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&#39; &#39;</span>),
    <span class="ruby-constant">WA_MULTIWORD</span>, <span class="ruby-identifier">lex</span>.<span class="ruby-identifier">select</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">l</span><span class="ruby-operator">|</span> <span class="ruby-identifier">l</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Lexical</span>) }))
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://rdoc.rubyforge.org">RDoc</a> 4.1.1.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

